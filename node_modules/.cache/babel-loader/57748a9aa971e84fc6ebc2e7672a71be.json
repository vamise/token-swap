{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deriveAssociatedTokenAddress = exports.resolveOrCreateAssociatedTokenAddress = void 0;\n\nvar spl_token_1 = require(\"@solana/spl-token\");\n\nvar web3_js_1 = require(\"@solana/web3.js\");\n\nvar tokens_1 = require(\"../../../constants/tokens\");\n\nvar constants_1 = require(\"../constants\");\n\nvar instruction_1 = require(\"../models/instruction\");\n\nvar deserialize_account_1 = require(\"./deserialize-account\");\n\nvar token_instructions_1 = require(\"./instructions/token-instructions\");\n/**\n * IMPORTANT: wrappedSolAmountIn should only be used for input/source token that\n *            could be SOL. This is because when SOL is the output, it is the end\n *            destination, and thus does not need to be wrapped with an amount.\n *\n * @param connection Solana connection class\n * @param owner The keypair for the user's wallet or just the user's public key\n * @param tokenMint Token mint address\n * @param wrappedSolAmountIn Optional. Only use for input/source token that could be SOL\n * @returns\n */\n\n\nfunction resolveOrCreateAssociatedTokenAddress(connection, owner, tokenMint) {\n  var wrappedSolAmountIn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new spl_token_1.u64(0);\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n    var derivedAddress, resolveAtaInstruction, accountRentExempt;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            if (tokenMint.equals(tokens_1.solToken.mint)) {\n              _context.next = 10;\n              break;\n            }\n\n            _context.next = 3;\n            return deriveAssociatedTokenAddress(owner.publicKey, tokenMint);\n\n          case 3:\n            derivedAddress = _context.sent;\n            // Check if current wallet has an ATA for this spl-token mint. If not, create one.\n            resolveAtaInstruction = instruction_1.emptyInstruction;\n            _context.next = 7;\n            return connection.getAccountInfo(derivedAddress).then(function (info) {\n              var tokenAccountInfo = (0, deserialize_account_1.deserializeAccount)(info === null || info === void 0 ? void 0 : info.data);\n\n              if (!tokenAccountInfo) {\n                resolveAtaInstruction = (0, token_instructions_1.createAssociatedTokenAccountInstruction)(derivedAddress, owner.publicKey, owner.publicKey, tokenMint, owner);\n              }\n            });\n\n          case 7:\n            return _context.abrupt(\"return\", {\n              address: derivedAddress,\n              instructions: resolveAtaInstruction.instructions,\n              cleanupInstructions: resolveAtaInstruction.cleanupInstructions,\n              signers: resolveAtaInstruction.signers\n            });\n\n          case 10:\n            _context.next = 12;\n            return connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);\n\n          case 12:\n            accountRentExempt = _context.sent;\n            return _context.abrupt(\"return\", (0, token_instructions_1.createWSOLAccountInstructions)(owner.publicKey, tokens_1.solToken.mint, wrappedSolAmountIn, accountRentExempt));\n\n          case 14:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n}\n\nexports.resolveOrCreateAssociatedTokenAddress = resolveOrCreateAssociatedTokenAddress;\n\nfunction deriveAssociatedTokenAddress(walletAddress, tokenMint) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            _context2.next = 2;\n            return web3_js_1.PublicKey.findProgramAddress([walletAddress.toBuffer(), spl_token_1.TOKEN_PROGRAM_ID.toBuffer(), tokenMint.toBuffer()], constants_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID);\n\n          case 2:\n            return _context2.abrupt(\"return\", _context2.sent[0]);\n\n          case 3:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n}\n\nexports.deriveAssociatedTokenAddress = deriveAssociatedTokenAddress;","map":{"version":3,"sources":["/Users/mikovainio/FyFy/token-swap/node_modules/@orca-so/sdk/dist/public/utils/web3/ata-utils.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","deriveAssociatedTokenAddress","resolveOrCreateAssociatedTokenAddress","spl_token_1","require","web3_js_1","tokens_1","constants_1","instruction_1","deserialize_account_1","token_instructions_1","connection","owner","tokenMint","wrappedSolAmountIn","u64","equals","solToken","mint","publicKey","derivedAddress","resolveAtaInstruction","emptyInstruction","getAccountInfo","info","tokenAccountInfo","deserializeAccount","data","createAssociatedTokenAccountInstruction","address","instructions","cleanupInstructions","signers","getMinimumBalanceForRentExemption","AccountLayout","span","accountRentExempt","createWSOLAccountInstructions","walletAddress","PublicKey","findProgramAddress","toBuffer","TOKEN_PROGRAM_ID","SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deriveAssociatedTokenAddress = exports.resolveOrCreateAssociatedTokenAddress = void 0;\nconst spl_token_1 = require(\"@solana/spl-token\");\nconst web3_js_1 = require(\"@solana/web3.js\");\nconst tokens_1 = require(\"../../../constants/tokens\");\nconst constants_1 = require(\"../constants\");\nconst instruction_1 = require(\"../models/instruction\");\nconst deserialize_account_1 = require(\"./deserialize-account\");\nconst token_instructions_1 = require(\"./instructions/token-instructions\");\n/**\n * IMPORTANT: wrappedSolAmountIn should only be used for input/source token that\n *            could be SOL. This is because when SOL is the output, it is the end\n *            destination, and thus does not need to be wrapped with an amount.\n *\n * @param connection Solana connection class\n * @param owner The keypair for the user's wallet or just the user's public key\n * @param tokenMint Token mint address\n * @param wrappedSolAmountIn Optional. Only use for input/source token that could be SOL\n * @returns\n */\nfunction resolveOrCreateAssociatedTokenAddress(connection, owner, tokenMint, wrappedSolAmountIn = new spl_token_1.u64(0)) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tokenMint.equals(tokens_1.solToken.mint)) {\n            const derivedAddress = yield deriveAssociatedTokenAddress(owner.publicKey, tokenMint);\n            // Check if current wallet has an ATA for this spl-token mint. If not, create one.\n            let resolveAtaInstruction = instruction_1.emptyInstruction;\n            yield connection.getAccountInfo(derivedAddress).then((info) => {\n                const tokenAccountInfo = (0, deserialize_account_1.deserializeAccount)(info === null || info === void 0 ? void 0 : info.data);\n                if (!tokenAccountInfo) {\n                    resolveAtaInstruction = (0, token_instructions_1.createAssociatedTokenAccountInstruction)(derivedAddress, owner.publicKey, owner.publicKey, tokenMint, owner);\n                }\n            });\n            return {\n                address: derivedAddress,\n                instructions: resolveAtaInstruction.instructions,\n                cleanupInstructions: resolveAtaInstruction.cleanupInstructions,\n                signers: resolveAtaInstruction.signers,\n            };\n        }\n        else {\n            // TODO: Is there a way to store this cleaner?\n            const accountRentExempt = yield connection.getMinimumBalanceForRentExemption(spl_token_1.AccountLayout.span);\n            // Create a temp-account to transfer SOL in the form of WSOL\n            return (0, token_instructions_1.createWSOLAccountInstructions)(owner.publicKey, tokens_1.solToken.mint, wrappedSolAmountIn, accountRentExempt);\n        }\n    });\n}\nexports.resolveOrCreateAssociatedTokenAddress = resolveOrCreateAssociatedTokenAddress;\nfunction deriveAssociatedTokenAddress(walletAddress, tokenMint) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return (yield web3_js_1.PublicKey.findProgramAddress([walletAddress.toBuffer(), spl_token_1.TOKEN_PROGRAM_ID.toBuffer(), tokenMint.toBuffer()], constants_1.SPL_ASSOCIATED_TOKEN_ACCOUNT_PROGRAM_ID))[0];\n    });\n}\nexports.deriveAssociatedTokenAddress = deriveAssociatedTokenAddress;\n"]},"metadata":{},"sourceType":"script"}