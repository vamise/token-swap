{"ast":null,"code":"import _asyncToGenerator from \"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _toConsumableArray from \"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _regeneratorRuntime from \"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/regenerator/index.js\";\nimport { WalletNotConnectedError, WalletNotReadyError, WalletReadyState } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.mjs';\nimport { useLocalStorage } from './useLocalStorage.mjs';\nimport { WalletContext } from './useWallet.mjs';\nvar initialState = {\n  wallet: null,\n  adapter: null,\n  publicKey: null,\n  connected: false\n};\nexport var WalletProvider = function WalletProvider(_ref) {\n  var children = _ref.children,\n      adapters = _ref.wallets,\n      _ref$autoConnect = _ref.autoConnect,\n      autoConnect = _ref$autoConnect === void 0 ? false : _ref$autoConnect,\n      onError = _ref.onError,\n      _ref$localStorageKey = _ref.localStorageKey,\n      localStorageKey = _ref$localStorageKey === void 0 ? 'walletName' : _ref$localStorageKey;\n\n  var _useLocalStorage = useLocalStorage(localStorageKey, null),\n      _useLocalStorage2 = _slicedToArray(_useLocalStorage, 2),\n      name = _useLocalStorage2[0],\n      setName = _useLocalStorage2[1];\n\n  var _useState = useState(initialState),\n      _useState2 = _slicedToArray(_useState, 2),\n      _useState2$ = _useState2[0],\n      wallet = _useState2$.wallet,\n      adapter = _useState2$.adapter,\n      publicKey = _useState2$.publicKey,\n      connected = _useState2$.connected,\n      setState = _useState2[1];\n\n  var readyState = (adapter === null || adapter === void 0 ? void 0 : adapter.readyState) || WalletReadyState.Unsupported;\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      connecting = _useState4[0],\n      setConnecting = _useState4[1];\n\n  var _useState5 = useState(false),\n      _useState6 = _slicedToArray(_useState5, 2),\n      disconnecting = _useState6[0],\n      setDisconnecting = _useState6[1];\n\n  var isConnecting = useRef(false);\n  var isDisconnecting = useRef(false);\n  var isUnloading = useRef(false); // Wrap adapters to conform to the `Wallet` interface\n\n  var _useState7 = useState(function () {\n    return adapters.map(function (adapter) {\n      return {\n        adapter: adapter,\n        readyState: adapter.readyState\n      };\n    });\n  }),\n      _useState8 = _slicedToArray(_useState7, 2),\n      wallets = _useState8[0],\n      setWallets = _useState8[1]; // When the wallets change, start to listen for changes to their `readyState`\n\n\n  useEffect(function () {\n    function handleReadyStateChange(readyState) {\n      var _this = this;\n\n      setWallets(function (prevWallets) {\n        var walletIndex = prevWallets.findIndex(function (_ref2) {\n          var adapter = _ref2.adapter;\n          return adapter.name === _this.name;\n        });\n        if (walletIndex === -1) return prevWallets;\n        return [].concat(_toConsumableArray(prevWallets.slice(0, walletIndex)), [_objectSpread(_objectSpread({}, prevWallets[walletIndex]), {}, {\n          readyState: readyState\n        })], _toConsumableArray(prevWallets.slice(walletIndex + 1)));\n      });\n    }\n\n    var _iterator = _createForOfIteratorHelper(adapters),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _adapter2 = _step.value;\n\n        _adapter2.on('readyStateChange', handleReadyStateChange, _adapter2);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return function () {\n      var _iterator2 = _createForOfIteratorHelper(adapters),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _adapter = _step2.value;\n\n          _adapter.off('readyStateChange', handleReadyStateChange, _adapter);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, [adapters]); // When the selected wallet changes, initialize the state\n\n  useEffect(function () {\n    var wallet = wallets.find(function (_ref3) {\n      var adapter = _ref3.adapter;\n      return adapter.name === name;\n    });\n\n    if (wallet) {\n      setState({\n        wallet: wallet,\n        adapter: wallet.adapter,\n        connected: wallet.adapter.connected,\n        publicKey: wallet.adapter.publicKey\n      });\n    } else {\n      setState(initialState);\n    }\n  }, [name, wallets]); // If autoConnect is enabled, try to connect when the adapter changes and is ready\n\n  useEffect(function () {\n    if (isConnecting.current || connecting || connected || !autoConnect || !adapter || !(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) return;\n\n    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              isConnecting.current = true;\n              setConnecting(true);\n              _context.prev = 2;\n              _context.next = 5;\n              return adapter.connect();\n\n            case 5:\n              _context.next = 10;\n              break;\n\n            case 7:\n              _context.prev = 7;\n              _context.t0 = _context[\"catch\"](2);\n              // Clear the selected wallet\n              setName(null); // Don't throw error, but handleError will still be called\n\n            case 10:\n              _context.prev = 10;\n              setConnecting(false);\n              isConnecting.current = false;\n              return _context.finish(10);\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 7, 10, 14]]);\n    }))();\n  }, [isConnecting, connecting, connected, autoConnect, adapter, readyState]); // If the window is closing or reloading, ignore disconnect and error events from the adapter\n\n  useEffect(function () {\n    function listener() {\n      isUnloading.current = true;\n    }\n\n    window.addEventListener('beforeunload', listener);\n    return function () {\n      return window.removeEventListener('beforeunload', listener);\n    };\n  }, [isUnloading]); // Handle the adapter's connect event\n\n  var handleConnect = useCallback(function () {\n    if (!adapter) return;\n    setState(function (state) {\n      return _objectSpread(_objectSpread({}, state), {}, {\n        connected: adapter.connected,\n        publicKey: adapter.publicKey\n      });\n    });\n  }, [adapter]); // Handle the adapter's disconnect event\n\n  var handleDisconnect = useCallback(function () {\n    // Clear the selected wallet unless the window is unloading\n    if (!isUnloading.current) setName(null);\n  }, [isUnloading]); // Handle the adapter's error event, and local errors\n\n  var handleError = useCallback(function (error) {\n    // Call onError unless the window is unloading\n    if (!isUnloading.current) (onError || console.error)(error);\n    return error;\n  }, [isUnloading, onError]); // Setup and teardown event listeners when the adapter changes\n\n  useEffect(function () {\n    if (adapter) {\n      adapter.on('connect', handleConnect);\n      adapter.on('disconnect', handleDisconnect);\n      adapter.on('error', handleError);\n      return function () {\n        adapter.off('connect', handleConnect);\n        adapter.off('disconnect', handleDisconnect);\n        adapter.off('error', handleError);\n      };\n    }\n  }, [adapter, handleConnect, handleDisconnect, handleError]); // When the adapter changes, disconnect the old one\n\n  useEffect(function () {\n    return function () {\n      adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();\n    };\n  }, [adapter]); // Connect the adapter to the wallet\n\n  var connect = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (!(isConnecting.current || connecting || disconnecting || connected)) {\n              _context2.next = 2;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 2:\n            if (adapter) {\n              _context2.next = 4;\n              break;\n            }\n\n            throw handleError(new WalletNotSelectedError());\n\n          case 4:\n            if (readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable) {\n              _context2.next = 8;\n              break;\n            }\n\n            // Clear the selected wallet\n            setName(null);\n\n            if (typeof window !== 'undefined') {\n              window.open(adapter.url, '_blank');\n            }\n\n            throw handleError(new WalletNotReadyError());\n\n          case 8:\n            isConnecting.current = true;\n            setConnecting(true);\n            _context2.prev = 10;\n            _context2.next = 13;\n            return adapter.connect();\n\n          case 13:\n            _context2.next = 19;\n            break;\n\n          case 15:\n            _context2.prev = 15;\n            _context2.t0 = _context2[\"catch\"](10);\n            // Clear the selected wallet\n            setName(null); // Rethrow the error, and handleError will also be called\n\n            throw _context2.t0;\n\n          case 19:\n            _context2.prev = 19;\n            setConnecting(false);\n            isConnecting.current = false;\n            return _context2.finish(19);\n\n          case 23:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, null, [[10, 15, 19, 23]]);\n  })), [isConnecting, connecting, disconnecting, connected, adapter, readyState, handleError]); // Disconnect the adapter from the wallet\n\n  var disconnect = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            if (!(isDisconnecting.current || disconnecting)) {\n              _context3.next = 2;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 2:\n            if (adapter) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\", setName(null));\n\n          case 4:\n            isDisconnecting.current = true;\n            setDisconnecting(true);\n            _context3.prev = 6;\n            _context3.next = 9;\n            return adapter.disconnect();\n\n          case 9:\n            _context3.next = 15;\n            break;\n\n          case 11:\n            _context3.prev = 11;\n            _context3.t0 = _context3[\"catch\"](6);\n            // Clear the selected wallet\n            setName(null); // Rethrow the error, and handleError will also be called\n\n            throw _context3.t0;\n\n          case 15:\n            _context3.prev = 15;\n            setDisconnecting(false);\n            isDisconnecting.current = false;\n            return _context3.finish(15);\n\n          case 19:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, null, [[6, 11, 15, 19]]);\n  })), [isDisconnecting, disconnecting, adapter]); // Send a transaction using the provided connection\n\n  var sendTransaction = useCallback( /*#__PURE__*/function () {\n    var _ref7 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(transaction, connection, options) {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (adapter) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw handleError(new WalletNotSelectedError());\n\n            case 2:\n              if (connected) {\n                _context4.next = 4;\n                break;\n              }\n\n              throw handleError(new WalletNotConnectedError());\n\n            case 4:\n              _context4.next = 6;\n              return adapter.sendTransaction(transaction, connection, options);\n\n            case 6:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n\n    return function (_x, _x2, _x3) {\n      return _ref7.apply(this, arguments);\n    };\n  }(), [adapter, handleError, connected]); // Sign a transaction if the wallet supports it\n\n  var signTransaction = useMemo(function () {\n    return adapter && 'signTransaction' in adapter ? /*#__PURE__*/function () {\n      var _ref8 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(transaction) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (connected) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw handleError(new WalletNotConnectedError());\n\n              case 2:\n                _context5.next = 4;\n                return adapter.signTransaction(transaction);\n\n              case 4:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n\n      return function (_x4) {\n        return _ref8.apply(this, arguments);\n      };\n    }() : undefined;\n  }, [adapter, handleError, connected]); // Sign multiple transactions if the wallet supports it\n\n  var signAllTransactions = useMemo(function () {\n    return adapter && 'signAllTransactions' in adapter ? /*#__PURE__*/function () {\n      var _ref9 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(transactions) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (connected) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw handleError(new WalletNotConnectedError());\n\n              case 2:\n                _context6.next = 4;\n                return adapter.signAllTransactions(transactions);\n\n              case 4:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n\n      return function (_x5) {\n        return _ref9.apply(this, arguments);\n      };\n    }() : undefined;\n  }, [adapter, handleError, connected]); // Sign an arbitrary message if the wallet supports it\n\n  var signMessage = useMemo(function () {\n    return adapter && 'signMessage' in adapter ? /*#__PURE__*/function () {\n      var _ref10 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(message) {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (connected) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw handleError(new WalletNotConnectedError());\n\n              case 2:\n                _context7.next = 4;\n                return adapter.signMessage(message);\n\n              case 4:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n\n      return function (_x6) {\n        return _ref10.apply(this, arguments);\n      };\n    }() : undefined;\n  }, [adapter, handleError, connected]);\n  return React.createElement(WalletContext.Provider, {\n    value: {\n      autoConnect: autoConnect,\n      wallets: wallets,\n      wallet: wallet,\n      publicKey: publicKey,\n      connected: connected,\n      connecting: connecting,\n      disconnecting: disconnecting,\n      select: setName,\n      connect: connect,\n      disconnect: disconnect,\n      sendTransaction: sendTransaction,\n      signTransaction: signTransaction,\n      signAllTransactions: signAllTransactions,\n      signMessage: signMessage\n    }\n  }, children);\n};","map":{"version":3,"sources":["../../src/WalletProvider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState, } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.mjs';\nimport { useLocalStorage } from './useLocalStorage.mjs';\nimport { WalletContext } from './useWallet.mjs';\nconst initialState = {\n    wallet: null,\n    adapter: null,\n    publicKey: null,\n    connected: false,\n};\nexport const WalletProvider = ({ children, wallets: adapters, autoConnect = false, onError, localStorageKey = 'walletName', }) => {\n    const [name, setName] = useLocalStorage(localStorageKey, null);\n    const [{ wallet, adapter, publicKey, connected }, setState] = useState(initialState);\n    const readyState = (adapter === null || adapter === void 0 ? void 0 : adapter.readyState) || WalletReadyState.Unsupported;\n    const [connecting, setConnecting] = useState(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const isConnecting = useRef(false);\n    const isDisconnecting = useRef(false);\n    const isUnloading = useRef(false);\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() => adapters.map((adapter) => ({\n        adapter,\n        readyState: adapter.readyState,\n    })));\n    // When the wallets change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        function handleReadyStateChange(readyState) {\n            setWallets((prevWallets) => {\n                const walletIndex = prevWallets.findIndex(({ adapter }) => adapter.name === this.name);\n                if (walletIndex === -1)\n                    return prevWallets;\n                return [\n                    ...prevWallets.slice(0, walletIndex),\n                    { ...prevWallets[walletIndex], readyState },\n                    ...prevWallets.slice(walletIndex + 1),\n                ];\n            });\n        }\n        for (const adapter of adapters) {\n            adapter.on('readyStateChange', handleReadyStateChange, adapter);\n        }\n        return () => {\n            for (const adapter of adapters) {\n                adapter.off('readyStateChange', handleReadyStateChange, adapter);\n            }\n        };\n    }, [adapters]);\n    // When the selected wallet changes, initialize the state\n    useEffect(() => {\n        const wallet = wallets.find(({ adapter }) => adapter.name === name);\n        if (wallet) {\n            setState({\n                wallet,\n                adapter: wallet.adapter,\n                connected: wallet.adapter.connected,\n                publicKey: wallet.adapter.publicKey,\n            });\n        }\n        else {\n            setState(initialState);\n        }\n    }, [name, wallets]);\n    // If autoConnect is enabled, try to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (isConnecting.current ||\n            connecting ||\n            connected ||\n            !autoConnect ||\n            !adapter ||\n            !(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable))\n            return;\n        (async function () {\n            isConnecting.current = true;\n            setConnecting(true);\n            try {\n                await adapter.connect();\n            }\n            catch (error) {\n                // Clear the selected wallet\n                setName(null);\n                // Don't throw error, but handleError will still be called\n            }\n            finally {\n                setConnecting(false);\n                isConnecting.current = false;\n            }\n        })();\n    }, [isConnecting, connecting, connected, autoConnect, adapter, readyState]);\n    // If the window is closing or reloading, ignore disconnect and error events from the adapter\n    useEffect(() => {\n        function listener() {\n            isUnloading.current = true;\n        }\n        window.addEventListener('beforeunload', listener);\n        return () => window.removeEventListener('beforeunload', listener);\n    }, [isUnloading]);\n    // Handle the adapter's connect event\n    const handleConnect = useCallback(() => {\n        if (!adapter)\n            return;\n        setState((state) => ({ ...state, connected: adapter.connected, publicKey: adapter.publicKey }));\n    }, [adapter]);\n    // Handle the adapter's disconnect event\n    const handleDisconnect = useCallback(() => {\n        // Clear the selected wallet unless the window is unloading\n        if (!isUnloading.current)\n            setName(null);\n    }, [isUnloading]);\n    // Handle the adapter's error event, and local errors\n    const handleError = useCallback((error) => {\n        // Call onError unless the window is unloading\n        if (!isUnloading.current)\n            (onError || console.error)(error);\n        return error;\n    }, [isUnloading, onError]);\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (adapter) {\n            adapter.on('connect', handleConnect);\n            adapter.on('disconnect', handleDisconnect);\n            adapter.on('error', handleError);\n            return () => {\n                adapter.off('connect', handleConnect);\n                adapter.off('disconnect', handleDisconnect);\n                adapter.off('error', handleError);\n            };\n        }\n    }, [adapter, handleConnect, handleDisconnect, handleError]);\n    // When the adapter changes, disconnect the old one\n    useEffect(() => {\n        return () => {\n            adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();\n        };\n    }, [adapter]);\n    // Connect the adapter to the wallet\n    const connect = useCallback(async () => {\n        if (isConnecting.current || connecting || disconnecting || connected)\n            return;\n        if (!adapter)\n            throw handleError(new WalletNotSelectedError());\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable)) {\n            // Clear the selected wallet\n            setName(null);\n            if (typeof window !== 'undefined') {\n                window.open(adapter.url, '_blank');\n            }\n            throw handleError(new WalletNotReadyError());\n        }\n        isConnecting.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        }\n        catch (error) {\n            // Clear the selected wallet\n            setName(null);\n            // Rethrow the error, and handleError will also be called\n            throw error;\n        }\n        finally {\n            setConnecting(false);\n            isConnecting.current = false;\n        }\n    }, [isConnecting, connecting, disconnecting, connected, adapter, readyState, handleError]);\n    // Disconnect the adapter from the wallet\n    const disconnect = useCallback(async () => {\n        if (isDisconnecting.current || disconnecting)\n            return;\n        if (!adapter)\n            return setName(null);\n        isDisconnecting.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        }\n        catch (error) {\n            // Clear the selected wallet\n            setName(null);\n            // Rethrow the error, and handleError will also be called\n            throw error;\n        }\n        finally {\n            setDisconnecting(false);\n            isDisconnecting.current = false;\n        }\n    }, [isDisconnecting, disconnecting, adapter]);\n    // Send a transaction using the provided connection\n    const sendTransaction = useCallback(async (transaction, connection, options) => {\n        if (!adapter)\n            throw handleError(new WalletNotSelectedError());\n        if (!connected)\n            throw handleError(new WalletNotConnectedError());\n        return await adapter.sendTransaction(transaction, connection, options);\n    }, [adapter, handleError, connected]);\n    // Sign a transaction if the wallet supports it\n    const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter\n        ? async (transaction) => {\n            if (!connected)\n                throw handleError(new WalletNotConnectedError());\n            return await adapter.signTransaction(transaction);\n        }\n        : undefined, [adapter, handleError, connected]);\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter\n        ? async (transactions) => {\n            if (!connected)\n                throw handleError(new WalletNotConnectedError());\n            return await adapter.signAllTransactions(transactions);\n        }\n        : undefined, [adapter, handleError, connected]);\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = useMemo(() => adapter && 'signMessage' in adapter\n        ? async (message) => {\n            if (!connected)\n                throw handleError(new WalletNotConnectedError());\n            return await adapter.signMessage(message);\n        }\n        : undefined, [adapter, handleError, connected]);\n    return (React.createElement(WalletContext.Provider, { value: {\n            autoConnect,\n            wallets,\n            wallet,\n            publicKey,\n            connected,\n            connecting,\n            disconnecting,\n            select: setName,\n            connect,\n            disconnect,\n            sendTransaction,\n            signTransaction,\n            signAllTransactions,\n            signMessage,\n        } }, children));\n};\n//# sourceMappingURL=WalletProvider.js.map"]},"metadata":{},"sourceType":"module"}