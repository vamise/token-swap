{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/regenerator/index.js\");\n\nvar _createForOfIteratorHelper = require(\"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\n\nvar _toConsumableArray = require(\"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\n\nvar _slicedToArray = require(\"/Users/mikovainio/FyFy/token-swap/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WalletProvider = void 0;\n\nvar wallet_adapter_base_1 = require(\"@solana/wallet-adapter-base\");\n\nvar react_1 = __importStar(require(\"react\"));\n\nvar errors_1 = require(\"./errors\");\n\nvar useLocalStorage_1 = require(\"./useLocalStorage\");\n\nvar useWallet_1 = require(\"./useWallet\");\n\nvar initialState = {\n  wallet: null,\n  adapter: null,\n  publicKey: null,\n  connected: false\n};\n\nvar WalletProvider = function WalletProvider(_ref) {\n  var children = _ref.children,\n      adapters = _ref.wallets,\n      _ref$autoConnect = _ref.autoConnect,\n      autoConnect = _ref$autoConnect === void 0 ? false : _ref$autoConnect,\n      onError = _ref.onError,\n      _ref$localStorageKey = _ref.localStorageKey,\n      localStorageKey = _ref$localStorageKey === void 0 ? 'walletName' : _ref$localStorageKey;\n\n  var _ref2 = (0, useLocalStorage_1.useLocalStorage)(localStorageKey, null),\n      _ref3 = _slicedToArray(_ref2, 2),\n      name = _ref3[0],\n      setName = _ref3[1];\n\n  var _ref4 = (0, react_1.useState)(initialState),\n      _ref5 = _slicedToArray(_ref4, 2),\n      _ref5$ = _ref5[0],\n      wallet = _ref5$.wallet,\n      adapter = _ref5$.adapter,\n      publicKey = _ref5$.publicKey,\n      connected = _ref5$.connected,\n      setState = _ref5[1];\n\n  var readyState = (adapter === null || adapter === void 0 ? void 0 : adapter.readyState) || wallet_adapter_base_1.WalletReadyState.Unsupported;\n\n  var _ref6 = (0, react_1.useState)(false),\n      _ref7 = _slicedToArray(_ref6, 2),\n      connecting = _ref7[0],\n      setConnecting = _ref7[1];\n\n  var _ref8 = (0, react_1.useState)(false),\n      _ref9 = _slicedToArray(_ref8, 2),\n      disconnecting = _ref9[0],\n      setDisconnecting = _ref9[1];\n\n  var isConnecting = (0, react_1.useRef)(false);\n  var isDisconnecting = (0, react_1.useRef)(false);\n  var isUnloading = (0, react_1.useRef)(false); // Wrap adapters to conform to the `Wallet` interface\n\n  var _ref10 = (0, react_1.useState)(function () {\n    return adapters.map(function (adapter) {\n      return {\n        adapter: adapter,\n        readyState: adapter.readyState\n      };\n    });\n  }),\n      _ref11 = _slicedToArray(_ref10, 2),\n      wallets = _ref11[0],\n      setWallets = _ref11[1]; // When the wallets change, start to listen for changes to their `readyState`\n\n\n  (0, react_1.useEffect)(function () {\n    function handleReadyStateChange(readyState) {\n      var _this = this;\n\n      setWallets(function (prevWallets) {\n        var walletIndex = prevWallets.findIndex(function (_ref12) {\n          var adapter = _ref12.adapter;\n          return adapter.name === _this.name;\n        });\n        if (walletIndex === -1) return prevWallets;\n        return [].concat(_toConsumableArray(prevWallets.slice(0, walletIndex)), [Object.assign(Object.assign({}, prevWallets[walletIndex]), {\n          readyState: readyState\n        })], _toConsumableArray(prevWallets.slice(walletIndex + 1)));\n      });\n    }\n\n    var _iterator = _createForOfIteratorHelper(adapters),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _adapter2 = _step.value;\n\n        _adapter2.on('readyStateChange', handleReadyStateChange, _adapter2);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    return function () {\n      var _iterator2 = _createForOfIteratorHelper(adapters),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _adapter = _step2.value;\n\n          _adapter.off('readyStateChange', handleReadyStateChange, _adapter);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    };\n  }, [adapters]); // When the selected wallet changes, initialize the state\n\n  (0, react_1.useEffect)(function () {\n    var wallet = wallets.find(function (_ref13) {\n      var adapter = _ref13.adapter;\n      return adapter.name === name;\n    });\n\n    if (wallet) {\n      setState({\n        wallet: wallet,\n        adapter: wallet.adapter,\n        connected: wallet.adapter.connected,\n        publicKey: wallet.adapter.publicKey\n      });\n    } else {\n      setState(initialState);\n    }\n  }, [name, wallets]); // If autoConnect is enabled, try to connect when the adapter changes and is ready\n\n  (0, react_1.useEffect)(function () {\n    if (isConnecting.current || connecting || connected || !autoConnect || !adapter || !(readyState === wallet_adapter_base_1.WalletReadyState.Installed || readyState === wallet_adapter_base_1.WalletReadyState.Loadable)) return;\n\n    (function () {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                isConnecting.current = true;\n                setConnecting(true);\n                _context.prev = 2;\n                _context.next = 5;\n                return adapter.connect();\n\n              case 5:\n                _context.next = 10;\n                break;\n\n              case 7:\n                _context.prev = 7;\n                _context.t0 = _context[\"catch\"](2);\n                // Clear the selected wallet\n                setName(null); // Don't throw error, but handleError will still be called\n\n              case 10:\n                _context.prev = 10;\n                setConnecting(false);\n                isConnecting.current = false;\n                return _context.finish(10);\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[2, 7, 10, 14]]);\n      }));\n    })();\n  }, [isConnecting, connecting, connected, autoConnect, adapter, readyState]); // If the window is closing or reloading, ignore disconnect and error events from the adapter\n\n  (0, react_1.useEffect)(function () {\n    function listener() {\n      isUnloading.current = true;\n    }\n\n    window.addEventListener('beforeunload', listener);\n    return function () {\n      return window.removeEventListener('beforeunload', listener);\n    };\n  }, [isUnloading]); // Handle the adapter's connect event\n\n  var handleConnect = (0, react_1.useCallback)(function () {\n    if (!adapter) return;\n    setState(function (state) {\n      return Object.assign(Object.assign({}, state), {\n        connected: adapter.connected,\n        publicKey: adapter.publicKey\n      });\n    });\n  }, [adapter]); // Handle the adapter's disconnect event\n\n  var handleDisconnect = (0, react_1.useCallback)(function () {\n    // Clear the selected wallet unless the window is unloading\n    if (!isUnloading.current) setName(null);\n  }, [isUnloading]); // Handle the adapter's error event, and local errors\n\n  var handleError = (0, react_1.useCallback)(function (error) {\n    // Call onError unless the window is unloading\n    if (!isUnloading.current) (onError || console.error)(error);\n    return error;\n  }, [isUnloading, onError]); // Setup and teardown event listeners when the adapter changes\n\n  (0, react_1.useEffect)(function () {\n    if (adapter) {\n      adapter.on('connect', handleConnect);\n      adapter.on('disconnect', handleDisconnect);\n      adapter.on('error', handleError);\n      return function () {\n        adapter.off('connect', handleConnect);\n        adapter.off('disconnect', handleDisconnect);\n        adapter.off('error', handleError);\n      };\n    }\n  }, [adapter, handleConnect, handleDisconnect, handleError]); // When the adapter changes, disconnect the old one\n\n  (0, react_1.useEffect)(function () {\n    return function () {\n      adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();\n    };\n  }, [adapter]); // Connect the adapter to the wallet\n\n  var connect = (0, react_1.useCallback)(function () {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              if (!(isConnecting.current || connecting || disconnecting || connected)) {\n                _context2.next = 2;\n                break;\n              }\n\n              return _context2.abrupt(\"return\");\n\n            case 2:\n              if (adapter) {\n                _context2.next = 4;\n                break;\n              }\n\n              throw handleError(new errors_1.WalletNotSelectedError());\n\n            case 4:\n              if (readyState === wallet_adapter_base_1.WalletReadyState.Installed || readyState === wallet_adapter_base_1.WalletReadyState.Loadable) {\n                _context2.next = 8;\n                break;\n              }\n\n              // Clear the selected wallet\n              setName(null);\n\n              if (typeof window !== 'undefined') {\n                window.open(adapter.url, '_blank');\n              }\n\n              throw handleError(new wallet_adapter_base_1.WalletNotReadyError());\n\n            case 8:\n              isConnecting.current = true;\n              setConnecting(true);\n              _context2.prev = 10;\n              _context2.next = 13;\n              return adapter.connect();\n\n            case 13:\n              _context2.next = 19;\n              break;\n\n            case 15:\n              _context2.prev = 15;\n              _context2.t0 = _context2[\"catch\"](10);\n              // Clear the selected wallet\n              setName(null); // Rethrow the error, and handleError will also be called\n\n              throw _context2.t0;\n\n            case 19:\n              _context2.prev = 19;\n              setConnecting(false);\n              isConnecting.current = false;\n              return _context2.finish(19);\n\n            case 23:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[10, 15, 19, 23]]);\n    }));\n  }, [isConnecting, connecting, disconnecting, connected, adapter, readyState, handleError]); // Disconnect the adapter from the wallet\n\n  var disconnect = (0, react_1.useCallback)(function () {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!(isDisconnecting.current || disconnecting)) {\n                _context3.next = 2;\n                break;\n              }\n\n              return _context3.abrupt(\"return\");\n\n            case 2:\n              if (adapter) {\n                _context3.next = 4;\n                break;\n              }\n\n              return _context3.abrupt(\"return\", setName(null));\n\n            case 4:\n              isDisconnecting.current = true;\n              setDisconnecting(true);\n              _context3.prev = 6;\n              _context3.next = 9;\n              return adapter.disconnect();\n\n            case 9:\n              _context3.next = 15;\n              break;\n\n            case 11:\n              _context3.prev = 11;\n              _context3.t0 = _context3[\"catch\"](6);\n              // Clear the selected wallet\n              setName(null); // Rethrow the error, and handleError will also be called\n\n              throw _context3.t0;\n\n            case 15:\n              _context3.prev = 15;\n              setDisconnecting(false);\n              isDisconnecting.current = false;\n              return _context3.finish(15);\n\n            case 19:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, null, [[6, 11, 15, 19]]);\n    }));\n  }, [isDisconnecting, disconnecting, adapter]); // Send a transaction using the provided connection\n\n  var sendTransaction = (0, react_1.useCallback)(function (transaction, connection, options) {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              if (adapter) {\n                _context4.next = 2;\n                break;\n              }\n\n              throw handleError(new errors_1.WalletNotSelectedError());\n\n            case 2:\n              if (connected) {\n                _context4.next = 4;\n                break;\n              }\n\n              throw handleError(new wallet_adapter_base_1.WalletNotConnectedError());\n\n            case 4:\n              _context4.next = 6;\n              return adapter.sendTransaction(transaction, connection, options);\n\n            case 6:\n              return _context4.abrupt(\"return\", _context4.sent);\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n  }, [adapter, handleError, connected]); // Sign a transaction if the wallet supports it\n\n  var signTransaction = (0, react_1.useMemo)(function () {\n    return adapter && 'signTransaction' in adapter ? function (transaction) {\n      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (connected) {\n                  _context5.next = 2;\n                  break;\n                }\n\n                throw handleError(new wallet_adapter_base_1.WalletNotConnectedError());\n\n              case 2:\n                _context5.next = 4;\n                return adapter.signTransaction(transaction);\n\n              case 4:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 5:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5);\n      }));\n    } : undefined;\n  }, [adapter, handleError, connected]); // Sign multiple transactions if the wallet supports it\n\n  var signAllTransactions = (0, react_1.useMemo)(function () {\n    return adapter && 'signAllTransactions' in adapter ? function (transactions) {\n      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                if (connected) {\n                  _context6.next = 2;\n                  break;\n                }\n\n                throw handleError(new wallet_adapter_base_1.WalletNotConnectedError());\n\n              case 2:\n                _context6.next = 4;\n                return adapter.signAllTransactions(transactions);\n\n              case 4:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 5:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6);\n      }));\n    } : undefined;\n  }, [adapter, handleError, connected]); // Sign an arbitrary message if the wallet supports it\n\n  var signMessage = (0, react_1.useMemo)(function () {\n    return adapter && 'signMessage' in adapter ? function (message) {\n      return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (connected) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw handleError(new wallet_adapter_base_1.WalletNotConnectedError());\n\n              case 2:\n                _context7.next = 4;\n                return adapter.signMessage(message);\n\n              case 4:\n                return _context7.abrupt(\"return\", _context7.sent);\n\n              case 5:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7);\n      }));\n    } : undefined;\n  }, [adapter, handleError, connected]);\n  return react_1.default.createElement(useWallet_1.WalletContext.Provider, {\n    value: {\n      autoConnect: autoConnect,\n      wallets: wallets,\n      wallet: wallet,\n      publicKey: publicKey,\n      connected: connected,\n      connecting: connecting,\n      disconnecting: disconnecting,\n      select: setName,\n      connect: connect,\n      disconnect: disconnect,\n      sendTransaction: sendTransaction,\n      signTransaction: signTransaction,\n      signAllTransactions: signAllTransactions,\n      signMessage: signMessage\n    }\n  }, children);\n};\n\nexports.WalletProvider = WalletProvider;","map":{"version":3,"sources":["../../src/WalletProvider.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WalletProvider = void 0;\nconst wallet_adapter_base_1 = require(\"@solana/wallet-adapter-base\");\nconst react_1 = __importStar(require(\"react\"));\nconst errors_1 = require(\"./errors\");\nconst useLocalStorage_1 = require(\"./useLocalStorage\");\nconst useWallet_1 = require(\"./useWallet\");\nconst initialState = {\n    wallet: null,\n    adapter: null,\n    publicKey: null,\n    connected: false,\n};\nconst WalletProvider = ({ children, wallets: adapters, autoConnect = false, onError, localStorageKey = 'walletName', }) => {\n    const [name, setName] = (0, useLocalStorage_1.useLocalStorage)(localStorageKey, null);\n    const [{ wallet, adapter, publicKey, connected }, setState] = (0, react_1.useState)(initialState);\n    const readyState = (adapter === null || adapter === void 0 ? void 0 : adapter.readyState) || wallet_adapter_base_1.WalletReadyState.Unsupported;\n    const [connecting, setConnecting] = (0, react_1.useState)(false);\n    const [disconnecting, setDisconnecting] = (0, react_1.useState)(false);\n    const isConnecting = (0, react_1.useRef)(false);\n    const isDisconnecting = (0, react_1.useRef)(false);\n    const isUnloading = (0, react_1.useRef)(false);\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = (0, react_1.useState)(() => adapters.map((adapter) => ({\n        adapter,\n        readyState: adapter.readyState,\n    })));\n    // When the wallets change, start to listen for changes to their `readyState`\n    (0, react_1.useEffect)(() => {\n        function handleReadyStateChange(readyState) {\n            setWallets((prevWallets) => {\n                const walletIndex = prevWallets.findIndex(({ adapter }) => adapter.name === this.name);\n                if (walletIndex === -1)\n                    return prevWallets;\n                return [\n                    ...prevWallets.slice(0, walletIndex),\n                    Object.assign(Object.assign({}, prevWallets[walletIndex]), { readyState }),\n                    ...prevWallets.slice(walletIndex + 1),\n                ];\n            });\n        }\n        for (const adapter of adapters) {\n            adapter.on('readyStateChange', handleReadyStateChange, adapter);\n        }\n        return () => {\n            for (const adapter of adapters) {\n                adapter.off('readyStateChange', handleReadyStateChange, adapter);\n            }\n        };\n    }, [adapters]);\n    // When the selected wallet changes, initialize the state\n    (0, react_1.useEffect)(() => {\n        const wallet = wallets.find(({ adapter }) => adapter.name === name);\n        if (wallet) {\n            setState({\n                wallet,\n                adapter: wallet.adapter,\n                connected: wallet.adapter.connected,\n                publicKey: wallet.adapter.publicKey,\n            });\n        }\n        else {\n            setState(initialState);\n        }\n    }, [name, wallets]);\n    // If autoConnect is enabled, try to connect when the adapter changes and is ready\n    (0, react_1.useEffect)(() => {\n        if (isConnecting.current ||\n            connecting ||\n            connected ||\n            !autoConnect ||\n            !adapter ||\n            !(readyState === wallet_adapter_base_1.WalletReadyState.Installed || readyState === wallet_adapter_base_1.WalletReadyState.Loadable))\n            return;\n        (function () {\n            return __awaiter(this, void 0, void 0, function* () {\n                isConnecting.current = true;\n                setConnecting(true);\n                try {\n                    yield adapter.connect();\n                }\n                catch (error) {\n                    // Clear the selected wallet\n                    setName(null);\n                    // Don't throw error, but handleError will still be called\n                }\n                finally {\n                    setConnecting(false);\n                    isConnecting.current = false;\n                }\n            });\n        })();\n    }, [isConnecting, connecting, connected, autoConnect, adapter, readyState]);\n    // If the window is closing or reloading, ignore disconnect and error events from the adapter\n    (0, react_1.useEffect)(() => {\n        function listener() {\n            isUnloading.current = true;\n        }\n        window.addEventListener('beforeunload', listener);\n        return () => window.removeEventListener('beforeunload', listener);\n    }, [isUnloading]);\n    // Handle the adapter's connect event\n    const handleConnect = (0, react_1.useCallback)(() => {\n        if (!adapter)\n            return;\n        setState((state) => (Object.assign(Object.assign({}, state), { connected: adapter.connected, publicKey: adapter.publicKey })));\n    }, [adapter]);\n    // Handle the adapter's disconnect event\n    const handleDisconnect = (0, react_1.useCallback)(() => {\n        // Clear the selected wallet unless the window is unloading\n        if (!isUnloading.current)\n            setName(null);\n    }, [isUnloading]);\n    // Handle the adapter's error event, and local errors\n    const handleError = (0, react_1.useCallback)((error) => {\n        // Call onError unless the window is unloading\n        if (!isUnloading.current)\n            (onError || console.error)(error);\n        return error;\n    }, [isUnloading, onError]);\n    // Setup and teardown event listeners when the adapter changes\n    (0, react_1.useEffect)(() => {\n        if (adapter) {\n            adapter.on('connect', handleConnect);\n            adapter.on('disconnect', handleDisconnect);\n            adapter.on('error', handleError);\n            return () => {\n                adapter.off('connect', handleConnect);\n                adapter.off('disconnect', handleDisconnect);\n                adapter.off('error', handleError);\n            };\n        }\n    }, [adapter, handleConnect, handleDisconnect, handleError]);\n    // When the adapter changes, disconnect the old one\n    (0, react_1.useEffect)(() => {\n        return () => {\n            adapter === null || adapter === void 0 ? void 0 : adapter.disconnect();\n        };\n    }, [adapter]);\n    // Connect the adapter to the wallet\n    const connect = (0, react_1.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {\n        if (isConnecting.current || connecting || disconnecting || connected)\n            return;\n        if (!adapter)\n            throw handleError(new errors_1.WalletNotSelectedError());\n        if (!(readyState === wallet_adapter_base_1.WalletReadyState.Installed || readyState === wallet_adapter_base_1.WalletReadyState.Loadable)) {\n            // Clear the selected wallet\n            setName(null);\n            if (typeof window !== 'undefined') {\n                window.open(adapter.url, '_blank');\n            }\n            throw handleError(new wallet_adapter_base_1.WalletNotReadyError());\n        }\n        isConnecting.current = true;\n        setConnecting(true);\n        try {\n            yield adapter.connect();\n        }\n        catch (error) {\n            // Clear the selected wallet\n            setName(null);\n            // Rethrow the error, and handleError will also be called\n            throw error;\n        }\n        finally {\n            setConnecting(false);\n            isConnecting.current = false;\n        }\n    }), [isConnecting, connecting, disconnecting, connected, adapter, readyState, handleError]);\n    // Disconnect the adapter from the wallet\n    const disconnect = (0, react_1.useCallback)(() => __awaiter(void 0, void 0, void 0, function* () {\n        if (isDisconnecting.current || disconnecting)\n            return;\n        if (!adapter)\n            return setName(null);\n        isDisconnecting.current = true;\n        setDisconnecting(true);\n        try {\n            yield adapter.disconnect();\n        }\n        catch (error) {\n            // Clear the selected wallet\n            setName(null);\n            // Rethrow the error, and handleError will also be called\n            throw error;\n        }\n        finally {\n            setDisconnecting(false);\n            isDisconnecting.current = false;\n        }\n    }), [isDisconnecting, disconnecting, adapter]);\n    // Send a transaction using the provided connection\n    const sendTransaction = (0, react_1.useCallback)((transaction, connection, options) => __awaiter(void 0, void 0, void 0, function* () {\n        if (!adapter)\n            throw handleError(new errors_1.WalletNotSelectedError());\n        if (!connected)\n            throw handleError(new wallet_adapter_base_1.WalletNotConnectedError());\n        return yield adapter.sendTransaction(transaction, connection, options);\n    }), [adapter, handleError, connected]);\n    // Sign a transaction if the wallet supports it\n    const signTransaction = (0, react_1.useMemo)(() => adapter && 'signTransaction' in adapter\n        ? (transaction) => __awaiter(void 0, void 0, void 0, function* () {\n            if (!connected)\n                throw handleError(new wallet_adapter_base_1.WalletNotConnectedError());\n            return yield adapter.signTransaction(transaction);\n        })\n        : undefined, [adapter, handleError, connected]);\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = (0, react_1.useMemo)(() => adapter && 'signAllTransactions' in adapter\n        ? (transactions) => __awaiter(void 0, void 0, void 0, function* () {\n            if (!connected)\n                throw handleError(new wallet_adapter_base_1.WalletNotConnectedError());\n            return yield adapter.signAllTransactions(transactions);\n        })\n        : undefined, [adapter, handleError, connected]);\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = (0, react_1.useMemo)(() => adapter && 'signMessage' in adapter\n        ? (message) => __awaiter(void 0, void 0, void 0, function* () {\n            if (!connected)\n                throw handleError(new wallet_adapter_base_1.WalletNotConnectedError());\n            return yield adapter.signMessage(message);\n        })\n        : undefined, [adapter, handleError, connected]);\n    return (react_1.default.createElement(useWallet_1.WalletContext.Provider, { value: {\n            autoConnect,\n            wallets,\n            wallet,\n            publicKey,\n            connected,\n            connecting,\n            disconnecting,\n            select: setName,\n            connect,\n            disconnect,\n            sendTransaction,\n            signTransaction,\n            signAllTransactions,\n            signMessage,\n        } }, children));\n};\nexports.WalletProvider = WalletProvider;\n//# sourceMappingURL=WalletProvider.js.map"]},"metadata":{},"sourceType":"script"}